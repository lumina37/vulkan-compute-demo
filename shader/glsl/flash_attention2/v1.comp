#version 460

layout (local_size_x_id = 0) in;

layout (binding = 0, std430) readonly buffer SrcQ { float srcQ[]; };
layout (binding = 1, std430) readonly buffer SrcK { float srcK[]; };
layout (binding = 2, std430) readonly buffer SrcV { float srcV[]; };
layout (binding = 3, std430) writeonly buffer DstO { float dstO[]; };

layout (constant_id = 1) const uint d = 128;// head dim
layout (constant_id = 2) const uint N = 0;// seq len
layout (constant_id = 3) const uint BrForQ = 16;// divides Q
layout (constant_id = 4) const uint BcForKV = 16;// divides K/V

shared float sQ[BrForQ][d];
shared float sK[BcForKV][d];
shared float sV[BcForKV][d];
shared float sO[BrForQ][d];
shared float sQK[BcForKV][BrForQ];// transposed
shared float sMaxQK[2][BrForQ];
shared float sAdjustFactor[BrForQ];
shared float sRowExpSum[BrForQ];

void main() {
    const uint groupSize = gl_WorkGroupSize.x;
    const uint localID = gl_LocalInvocationIndex;
    const uint groupID = gl_WorkGroupID.x;
    const float invSqrtD = sqrt(1.0f / float(d));

    const uint KVIterCount = N / BcForKV;

    // Init accumulator
    if (localID < BrForQ) {
        sRowExpSum[localID] = 0;
        sMaxQK[0][localID] = -1. / 0.;
        sMaxQK[1][localID] = -1. / 0.;
    }

    // Load Q & zero-init O
    const uint loadsPerThreadQ = BrForQ * d / groupSize;
    for (uint i = 0; i < loadsPerThreadQ; i++) {
        const uint linearIdx = i * groupSize + localID;
        const uint x = linearIdx % d;
        const uint y = linearIdx / d;
        const uint srcX = x;
        const uint srcY = groupID * BrForQ + y;
        const uint srcIndex = srcY * d + srcX;
        sQ[y][x] = srcQ[srcIndex];
        sO[y][x] = 0;
    }

    const uint loadsPerThreadKV = BcForKV * d / groupSize;
    const uint computesPerThreadQK = BrForQ * BcForKV / groupSize;
    for (uint iterKV = 0; iterKV < KVIterCount; iterKV++) {
        // Load KV
        for (uint i = 0; i < loadsPerThreadKV; i++) {
            const uint linearIdx = i * groupSize + localID;
            const uint x = linearIdx % d;
            const uint y = linearIdx / d;
            const uint srcX = x;
            const uint srcY = iterKV * BcForKV + y;
            const uint srcIndex = srcY * d + srcX;
            sK[y][x] = srcK[srcIndex];
            sV[y][x] = srcV[srcIndex];
        }
        barrier();

        // Compute Q*K^T
        for (uint i = 0; i < computesPerThreadQK; i++) {
            const uint linearIdx = i * groupSize + localID;
            const uint x = linearIdx % BcForKV;
            const uint y = linearIdx / BcForKV;

            float acc = 0;
            for (uint iqk = 0; iqk < d; iqk++) {
                acc += sQ[y][iqk] * sK[x][iqk];
            }
            sQK[x][y] = acc * invSqrtD;// transposed
        }
        barrier();

        // Max element for each row
        const uint prevMaxQKIdx = (iterKV + 1) % 2;
        const uint currMaxQKIdx = iterKV % 2;
        if (localID < BrForQ) {
            for (uint i = 0; i < BcForKV; i++) {
                sMaxQK[currMaxQKIdx][localID] = max(sMaxQK[currMaxQKIdx][localID], sQK[i][localID]);
            }
            sAdjustFactor[localID] = exp(sMaxQK[prevMaxQKIdx][localID] - sMaxQK[currMaxQKIdx][localID]);
        }
        barrier();

        // Exp of sQK
        for (uint i = 0; i < computesPerThreadQK; i++) {
            const uint linearIdx = i * groupSize + localID;
            const uint x = linearIdx % BcForKV;
            const uint y = linearIdx / BcForKV;
            sQK[x][y] = exp(sQK[x][y] - sMaxQK[currMaxQKIdx][y]);// transposed
        }
        barrier();

        // Row expsum
        if (localID < BrForQ) {
            float rowExpSum = 0;
            for (uint i = 0; i < BcForKV; i++) {
                rowExpSum += sQK[i][localID];// transposed
            }
            sRowExpSum[localID] = sAdjustFactor[localID] * sRowExpSum[localID] + rowExpSum;
        }
        barrier();

        // Compute and adjust sO
        const uint computesPerThreadO = BrForQ * d / groupSize;
        for (uint i = 0; i < computesPerThreadO; i++) {
            const uint linearIdx = i * groupSize + localID;
            const uint x = linearIdx % d;
            const uint y = linearIdx / d;

            float acc = 0;
            for (uint io = 0; io < BcForKV; io++) {
                acc += sQK[io][y] * sV[io][x];// transposed
            }
            sO[y][x] = sAdjustFactor[y] * sO[y][x] + acc;
        }
        barrier();
    }

    // Compute final O with sRowExpSum (softmax divisor)
    const uint storesPerThreadO = BrForQ * d / groupSize;
    for (uint i = 0; i < storesPerThreadO; i++) {
        const uint linearIdx = i * groupSize + localID;
        const uint x = linearIdx % d;
        const uint y = linearIdx / d;
        const uint dstX = x;
        const uint dstY = groupID * BrForQ + y;
        const uint dstIndex = dstY * d + dstX;
        const float dstVal = sO[y][x] / sRowExpSum[y];
        dstO[dstIndex] = dstVal;
    }
}
