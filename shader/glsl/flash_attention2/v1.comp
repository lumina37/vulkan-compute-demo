#version 460

layout (local_size_x_id = 0) in;

layout (binding = 0, std430) readonly buffer SrcQ { float srcQ[]; };
layout (binding = 1, std430) readonly buffer SrcK { float srcK[]; };
layout (binding = 2, std430) readonly buffer SrcV { float srcV[]; };
layout (binding = 3, std430) writeonly buffer DstO { float dstO[]; };

layout (constant_id = 1) const int d = 128;// head dim
layout (constant_id = 2) const int N = 0;// seq len
layout (constant_id = 3) const int BrForQ = 16;// divides Q
layout (constant_id = 4) const int BcForKV = 16;// divides K/V

shared float sQ[BrForQ][d];
shared float sK[BcForKV][d];
shared float sV[BcForKV][d];
shared float sO[BrForQ][d];
shared float sQK[BcForKV][BrForQ];// transposed
shared float sMaxQK[2][BrForQ];
shared float sAdjustFactor[BrForQ];
shared float sRowExpSum[BrForQ];

void main() {
    const int groupSize = int(gl_WorkGroupSize.x);
    const int localID = int(gl_LocalInvocationID.x);
    const int groupID = int(gl_WorkGroupID.x);
    const float invSqrtD = sqrt(1.0f / float(d));

    const int KVIterCount = N / BcForKV;

    // Init accumulator
    if (localID < BrForQ) {
        sRowExpSum[localID] = 0;
        sMaxQK[0][localID] = -1. / 0.;
        sMaxQK[1][localID] = -1. / 0.;
    }

    // Load Q & zero-init O
    const int loadsPerThreadQ = BrForQ * d / groupSize;
    for (int i = 0; i < loadsPerThreadQ; i++) {
        const int linearIdx = i * groupSize + localID;
        const int x = linearIdx % d;
        const int y = linearIdx / d;
        const int srcX = x;
        const int srcY = groupID * BrForQ + y;
        const int srcIndex = srcY * d + srcX;
        sQ[y][x] = srcQ[srcIndex];
        sO[y][x] = 0;
    }

    const int loadsPerThreadKV = BcForKV * d / groupSize;
    const int computesPerThreadQK = BrForQ * BcForKV / groupSize;
    for (int iterKV = 0; iterKV < KVIterCount; iterKV++) {
        // Load KV
        for (int i = 0; i < loadsPerThreadKV; i++) {
            const int linearIdx = i * groupSize + localID;
            const int x = linearIdx % d;
            const int y = linearIdx / d;
            const int srcX = x;
            const int srcY = iterKV * BcForKV + y;
            const int srcIndex = srcY * d + srcX;
            sK[y][x] = srcK[srcIndex];
            sV[y][x] = srcV[srcIndex];
        }
        barrier();

        // Compute Q*K^T
        for (int i = 0; i < computesPerThreadQK; i++) {
            const int linearIdx = i * groupSize + localID;
            const int x = linearIdx % BcForKV;
            const int y = linearIdx / BcForKV;

            float acc = 0;
            for (int iqk = 0; iqk < d; iqk++) {
                acc += sQ[y][iqk] * sK[x][iqk];
            }
            sQK[x][y] = acc * invSqrtD;// transposed
        }
        barrier();

        // Max element for each row
        const int prevMaxQKIdx = (iterKV + 1) % 2;
        const int currMaxQKIdx = iterKV % 2;
        if (localID < BrForQ) {
            for (int i = 0; i < BcForKV; i++) {
                sMaxQK[currMaxQKIdx][localID] = max(sMaxQK[currMaxQKIdx][localID], sQK[i][localID]);
            }
            sAdjustFactor[localID] = exp(sMaxQK[prevMaxQKIdx][localID] - sMaxQK[currMaxQKIdx][localID]);
        }
        barrier();

        // Exp of sQK
        for (int i = 0; i < computesPerThreadQK; i++) {
            const int linearIdx = i * groupSize + localID;
            const int x = linearIdx % BcForKV;
            const int y = linearIdx / BcForKV;
            sQK[x][y] = exp(sQK[x][y] - sMaxQK[currMaxQKIdx][y]);// transposed
        }
        barrier();

        // Row expsum
        if (localID < BrForQ) {
            float rowExpSum = 0;
            for (int i = 0; i < BcForKV; i++) {
                rowExpSum += sQK[i][localID];// transposed
            }
            sRowExpSum[localID] = sAdjustFactor[localID] * sRowExpSum[localID] + rowExpSum;
        }
        barrier();

        // Compute and adjust sO
        const int computesPerThreadO = BrForQ * d / groupSize;
        for (int i = 0; i < computesPerThreadO; i++) {
            const int linearIdx = i * groupSize + localID;
            const int x = linearIdx % d;
            const int y = linearIdx / d;

            float acc = 0;
            for (int io = 0; io < BcForKV; io++) {
                acc += sQK[io][y] * sV[io][x];// transposed
            }
            sO[y][x] = sAdjustFactor[y] * sO[y][x] + acc;
        }
        barrier();
    }

    // Compute final O with sRowExpSum (softmax divisor)
    const int storesPerThreadO = BrForQ * d / groupSize;
    for (int i = 0; i < storesPerThreadO; i++) {
        const int linearIdx = i * groupSize + localID;
        const int x = linearIdx % d;
        const int y = linearIdx / d;
        const int dstX = x;
        const int dstY = groupID * BrForQ + y;
        const int dstIndex = dstY * d + dstX;
        const float dstVal = sO[y][x] / sRowExpSum[y];
        dstO[dstIndex] = dstVal;
    }
}
