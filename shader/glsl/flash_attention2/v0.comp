#version 460

layout (local_size_x_id = 0, local_size_y_id = 1) in;

layout (binding = 0, std430) readonly buffer SrcQ { float srcQ[]; };
layout (binding = 1, std430) readonly buffer SrcK { float srcK[]; };
layout (binding = 2, std430) readonly buffer SrcV { float srcV[]; };
layout (binding = 3, std430) writeonly buffer DstO { float dstO[]; };

layout (constant_id = 2) const uint d = 0;// head dim
layout (constant_id = 3) const uint N = 0;// seq len

void main() {
    const uvec2 globalID = gl_GlobalInvocationID.xy;
    const float invSqrtD = sqrt(1.0f / float(d));

    float outputSum = 0;
    float rowExpSum = 0;
    float maxQK = -1. / 0.;

    for (uint iterV = 0; iterV < N; iterV++) {
        float qkAcc = 0;
        for (uint iterQK = 0; iterQK < d; iterQK++) {
            const uint indexQ = globalID.y * d + iterQK;
            const float valQ = srcQ[indexQ];
            const uint indexK = iterV * d + iterQK;
            const float valK = srcK[indexK];
            qkAcc += valQ * valK;
        }
        qkAcc *= invSqrtD;

        const float currMaxQK = max(qkAcc, maxQK);
        const float adjustedQK = exp(qkAcc - currMaxQK);
        const float adjustAcc = exp(maxQK - currMaxQK);
        const uint indexV = iterV * d + globalID.x;
        const float valV = srcV[indexV];
        outputSum = outputSum * adjustAcc + adjustedQK * valV;
        rowExpSum = rowExpSum * adjustAcc + adjustedQK;
        maxQK = currMaxQK;
    }

    const uint indexDst = globalID.y * d + globalID.x;
    dstO[indexDst] = outputSum / rowExpSum;
}
