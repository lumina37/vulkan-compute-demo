#version 460

layout (local_size_x_id = 0, local_size_y_id = 1) in;

layout (binding = 0, r32f) uniform readonly image2D srcQ;
layout (binding = 1, r32f) uniform readonly image2D srcK;
layout (binding = 2, r32f) uniform readonly image2D srcV;
layout (binding = 3, r32f) uniform writeonly image2D dstO;

void main() {
    const ivec2 globalID = ivec2(gl_GlobalInvocationID.xy);
    const ivec2 matSize = imageSize(dstO);
    const int d = matSize.x;
    const int N = matSize.y;
    const float invSqrtD = sqrt(1.0f / float(d));

    float diviendAcc = 0;
    float divisorAcc = 0;
    float maxQK = 0;

    for (int iterV = 0; iterV < N; iterV++) {
        float qkAcc = 0;
        for (int iterQK = 0; iterQK < d; iterQK++) {
            const ivec2 coordQ = ivec2(iterQK, globalID.y);
            const vec4 valQ = imageLoad(srcQ, coordQ);
            const ivec2 coordK = ivec2(iterQK, iterV);
            const vec4 valK = imageLoad(srcK, coordK);
            qkAcc += valQ.x * valK.x;
        }
        qkAcc *= invSqrtD;

        const float currMaxQK = max(qkAcc, maxQK);
        const float adjustedQK = exp(qkAcc - currMaxQK);
        const float adjustAcc = exp(maxQK - currMaxQK);
        const ivec2 coordV = ivec2(globalID.x, iterV);
        const vec4 valV = imageLoad(srcV, coordV);
        diviendAcc = diviendAcc * adjustAcc + adjustedQK * valV.x;
        divisorAcc = divisorAcc * adjustAcc + adjustedQK;
        maxQK = currMaxQK;
    }

    const vec4 dstVal = vec4(diviendAcc / divisorAcc, 0.0, 0.0, 0.0);
    imageStore(dstO, globalID, dstVal);
}
