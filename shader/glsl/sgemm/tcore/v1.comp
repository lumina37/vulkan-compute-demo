// Block-tile

#version 460

#extension GL_EXT_shader_16bit_storage: require
#extension GL_EXT_shader_explicit_arithmetic_types_float16: require
#extension GL_KHR_memory_scope_semantics: require
#extension GL_KHR_cooperative_matrix: require
#extension GL_KHR_shader_subgroup_basic: require

layout (local_size_x_id = 0) in;

layout (binding = 0, std430) readonly buffer SrcMatA { float16_t srcMatA[]; };
layout (binding = 1, std430) readonly buffer SrcMatB { float16_t srcMatB[]; };
layout (binding = 2, std430) writeonly buffer DstMat { float dstMat[]; };

layout (constant_id = 1) const uint M = 0;
layout (constant_id = 2) const uint N = 0;
layout (constant_id = 3) const uint K = 0;
layout (constant_id = 4) const uint MMA_M = 16;
layout (constant_id = 5) const uint MMA_N = 16;
layout (constant_id = 6) const uint MMA_K = 16;
layout (constant_id = 7) const uint BLOCK_TILE_M = 32;
layout (constant_id = 8) const uint BLOCK_TILE_N = 32;
layout (constant_id = 9) const uint BLOCK_TILE_K = 32;

const uint WARP_COUNT_M = BLOCK_TILE_M / MMA_M;
const uint WARP_COUNT_N = BLOCK_TILE_N / MMA_N;

const uvec2 SHARED_EXTENT_A = uvec2(BLOCK_TILE_K, BLOCK_TILE_M);
const uvec2 SHARED_EXTENT_B = uvec2(BLOCK_TILE_N, BLOCK_TILE_K);
shared float16_t sharedA[BLOCK_TILE_M * BLOCK_TILE_K];
shared float16_t sharedB[BLOCK_TILE_K * BLOCK_TILE_N];

void zeroFillAccumulator(inout coopmat<float, gl_ScopeSubgroup, MMA_M, MMA_N, gl_MatrixUseAccumulator> coopmatAcc) {
    coopmatAcc = coopmat<float, gl_ScopeSubgroup, MMA_M, MMA_N, gl_MatrixUseAccumulator>(0.0);
}

void loadGlobalToShared(uvec2 globalCoord, uvec2 globalExtent, uint globalRowStride, bool loadA) {
    const uvec2 groupSize = gl_WorkGroupSize.xy;
    const uint localIndex = gl_LocalInvocationIndex;

    const uint groupThreadCount = groupSize.x * groupSize.y;
    const uint loadsPerThread = globalExtent.x * globalExtent.y / groupThreadCount;

    for (uint i = 0; i < loadsPerThread; i++) {
        const uint linearIdx = i * groupThreadCount + localIndex;
        const uvec2 srcOffset = uvec2(linearIdx % globalExtent.x, linearIdx / globalExtent.x);
        const uvec2 srcCoord = globalCoord + srcOffset;
        const uint srcIndex = srcCoord.y * globalRowStride + srcCoord.x;

        const uvec2 dstCoord = srcOffset;
        if (loadA) {
            sharedA[dstCoord.y * BLOCK_TILE_K + dstCoord.x] = srcMatA[srcIndex];
        } else {
            sharedB[dstCoord.y * BLOCK_TILE_N + dstCoord.x] = srcMatB[srcIndex];
        }
    }
}

void computeWithShared(inout coopmat<float, gl_ScopeSubgroup, MMA_M, MMA_N, gl_MatrixUseAccumulator> coopmatAcc) {
    const uvec2 groupID = gl_WorkGroupID.xy;
    const uint subgroupIndex = gl_SubgroupID;
    const uvec2 subgroupID = uvec2(subgroupIndex % WARP_COUNT_N, subgroupIndex / WARP_COUNT_N);

    coopmat<float16_t, gl_ScopeSubgroup, MMA_M, MMA_K, gl_MatrixUseA> matA;
    coopmat<float16_t, gl_ScopeSubgroup, MMA_K, MMA_N, gl_MatrixUseB> matB;

    const uint wrapSplitKCount = BLOCK_TILE_K / MMA_K;
    for (uint iWarpSplitK = 0; iWarpSplitK < wrapSplitKCount; iWarpSplitK++) {
        const uvec2 sharedCoordA = uvec2(iWarpSplitK * MMA_K, subgroupID.y * MMA_M);
        const uint sharedOffsetA = sharedCoordA.y * BLOCK_TILE_K + sharedCoordA.x;
        coopMatLoad(matA, sharedA, sharedOffsetA, BLOCK_TILE_K, gl_CooperativeMatrixLayoutRowMajor);

        const uvec2 sharedCoordB = uvec2(subgroupID.x * MMA_N, iWarpSplitK * MMA_K);
        const uint sharedOffsetB = sharedCoordB.y * BLOCK_TILE_N + sharedCoordB.x;
        coopMatLoad(matB, sharedB, sharedOffsetB, BLOCK_TILE_N, gl_CooperativeMatrixLayoutRowMajor);

        coopmatAcc = coopMatMulAdd(matA, matB, coopmatAcc);
    }
}

void storeAccumulator(coopmat<float, gl_ScopeSubgroup, MMA_M, MMA_N, gl_MatrixUseAccumulator> coopmatAcc) {
    const uvec2 groupID = gl_WorkGroupID.xy;
    const uint subgroupIndex = gl_SubgroupID;
    const uvec2 subgroupID = uvec2(subgroupIndex % WARP_COUNT_N, subgroupIndex / WARP_COUNT_N);

    const uint globalCoordY = groupID.y * BLOCK_TILE_M + subgroupID.y * MMA_M;
    const uint globalCoordX = groupID.x * BLOCK_TILE_N + subgroupID.x * MMA_N;
    const uint globalOffset = globalCoordY * N + globalCoordX;
    coopMatStore(coopmatAcc, dstMat, globalOffset, N, gl_CooperativeMatrixLayoutRowMajor);
}

void main() {
    const uvec2 groupID = gl_WorkGroupID.xy;

    coopmat<float, gl_ScopeSubgroup, MMA_M, MMA_N, gl_MatrixUseAccumulator> coopmatAcc;
    zeroFillAccumulator(coopmatAcc);

    const uint blockBaseM = groupID.y * BLOCK_TILE_M;
    const uint blockBaseN = groupID.x * BLOCK_TILE_N;
    const uint blockSplitKCount = K / BLOCK_TILE_K;
    for (uint iBlockSplitK = 0; iBlockSplitK < blockSplitKCount; iBlockSplitK++) {
        const uint blockBaseK = iBlockSplitK * BLOCK_TILE_K;

        const uvec2 globalCoordA = uvec2(blockBaseK, blockBaseM);
        loadGlobalToShared(globalCoordA, SHARED_EXTENT_A, K, true);// Load A

        const uvec2 globalCoordB = uvec2(blockBaseN, blockBaseK);
        loadGlobalToShared(globalCoordB, SHARED_EXTENT_B, N, false);// Load B
        barrier();

        computeWithShared(coopmatAcc);
        barrier();
    }

    storeAccumulator(coopmatAcc);
}
