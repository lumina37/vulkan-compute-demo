// Naive

#version 460

#extension GL_EXT_shader_16bit_storage: require
#extension GL_EXT_shader_explicit_arithmetic_types_float16: require
#extension GL_KHR_memory_scope_semantics: require
#extension GL_KHR_cooperative_matrix: require

layout (local_size_x_id = 0) in;

layout (binding = 0, std430) readonly buffer SrcMatA { float16_t srcMatA[]; };
layout (binding = 1, std430) readonly buffer SrcMatB { float16_t srcMatB[]; };
layout (binding = 2, std430) writeonly buffer DstMat { float dstMat[]; };

layout (constant_id = 1) const uint M = 0;
layout (constant_id = 2) const uint N = 0;
layout (constant_id = 3) const uint K = 0;
layout (constant_id = 4) const uint MMA_M = 16;
layout (constant_id = 5) const uint MMA_N = 16;
layout (constant_id = 6) const uint MMA_K = 16;

void main() {
    const uint groupSize = gl_WorkGroupSize.x;
    const uint localIndex = gl_LocalInvocationIndex;
    const uvec2 groupID = gl_WorkGroupID.xy;

    coopmat<float16_t, gl_ScopeSubgroup, MMA_M, MMA_K, gl_MatrixUseA> matA;
    coopmat<float16_t, gl_ScopeSubgroup, MMA_K, MMA_N, gl_MatrixUseB> matB;
    coopmat<float, gl_ScopeSubgroup, MMA_M, MMA_N, gl_MatrixUseAccumulator> coopmatAcc;
    coopmatAcc = coopmat<float, gl_ScopeSubgroup, MMA_M, MMA_N, gl_MatrixUseAccumulator>(0.0);

    const uint blockSplitKCount = K / MMA_K;
    const uint blockBaseM = groupID.y * MMA_M;
    const uint blockBaseN = groupID.x * MMA_N;
    for (uint iBlockSplitK = 0; iBlockSplitK < blockSplitKCount; iBlockSplitK++) {
        const uint blockBaseK = iBlockSplitK * MMA_K;

        coopMatLoad(matA, srcMatA, blockBaseM * K + blockBaseK, K, gl_CooperativeMatrixLayoutRowMajor);
        coopMatLoad(matB, srcMatB, blockBaseK * N + blockBaseN, N, gl_CooperativeMatrixLayoutRowMajor);

        coopmatAcc = coopMatMulAdd(matA, matB, coopmatAcc);
    }

    coopMatStore(coopmatAcc, dstMat, blockBaseM * N + blockBaseN, N, gl_CooperativeMatrixLayoutRowMajor);
}
