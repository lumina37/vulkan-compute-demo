// Block-tile

#version 460

#extension GL_EXT_control_flow_attributes : enable

layout (local_size_x_id = 0, local_size_y_id = 1) in;

layout (binding = 0, std430) readonly buffer SrcMatA { float srcMatA[]; };
layout (binding = 1, std430) readonly buffer SrcMatB { float srcMatB[]; };
layout (binding = 2, std430) writeonly buffer DstMat { float dstMat[]; };

layout (constant_id = 2) const uint M = 0;
layout (constant_id = 3) const uint N = 0;
layout (constant_id = 4) const uint K = 0;

shared float sharedA[gl_WorkGroupSize.y][gl_WorkGroupSize.x];
shared float sharedB[gl_WorkGroupSize.x][gl_WorkGroupSize.y];

void main() {
    const uvec2 globalID = gl_GlobalInvocationID.xy;
    const uvec2 groupSize = gl_WorkGroupSize.xy;
    const uvec2 localID = gl_LocalInvocationID.xy;

    float acc = 0.0;
    const uint splitKCount = K / groupSize.x;
    for (uint iSplitK = 0; iSplitK < splitKCount; iSplitK++) {
        // Load from srcMatA
        const uint srcX = iSplitK * groupSize.x + localID.x;
        const uint srcAIndex = globalID.y * K + srcX;
        sharedA[localID.y][localID.x] = srcMatA[srcAIndex];

        // Load from srcMatB
        const uint srcY = iSplitK * groupSize.y + localID.y;
        const uint srcBIndex = srcY * N + globalID.x;
        sharedB[localID.x][localID.y] = srcMatB[srcBIndex];// transposed
        barrier();

        // Compute
        [[unroll]] for (uint k = 0; k < groupSize.x; k++) {
            const float valA = sharedA[localID.y][k];
            const float valB = sharedB[localID.x][k];// transposed
            acc = fma(valA, valB, acc);
        }
        barrier();
    }

    const uint dstIndex = globalID.y * N + globalID.x;
    dstMat[dstIndex] = acc;
}
