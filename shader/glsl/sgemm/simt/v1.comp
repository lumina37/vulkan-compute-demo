// Block-tile

#version 460

#extension GL_EXT_control_flow_attributes : enable

layout (local_size_x_id = 0, local_size_y_id = 0) in;

layout (binding = 0, std430) readonly buffer SrcMatA { float srcMatA[]; };
layout (binding = 1, std430) readonly buffer SrcMatB { float srcMatB[]; };
layout (binding = 2, std430) writeonly buffer DstMat { float dstMat[]; };

layout (constant_id = 1) const uint M = 0;
layout (constant_id = 2) const uint N = 0;
layout (constant_id = 3) const uint K = 0;
layout (constant_id = 0) const uint BLOCK_TILE_MN = 16;
layout (constant_id = 4) const uint BLOCK_TILE_K = 16;

shared float sharedA[BLOCK_TILE_MN][BLOCK_TILE_K];
shared float sharedB[BLOCK_TILE_K][BLOCK_TILE_MN];

void main() {
    const uvec2 globalID = gl_GlobalInvocationID.xy;
    const uvec2 groupSize = gl_WorkGroupSize.xy;
    const uvec2 localID = gl_LocalInvocationID.xy;

    float acc = 0.0;
    [[unroll]] for (uint iterK = 0; iterK < K; iterK += BLOCK_TILE_K) {
        // Load from srcMatA
        const uvec2 globalCoordA = uvec2(iterK + localID.x, globalID.y);
        const uint srcIndexA = globalCoordA.y * K + globalCoordA.x;
        sharedA[localID.y][localID.x] = srcMatA[srcIndexA];

        // Load from srcMatB
        const uvec2 globalCoordB = uvec2(globalID.x, iterK + localID.y);
        const uint srcIndexB = globalCoordB.y * N + globalCoordB.x;
        sharedB[localID.x][localID.y] = srcMatB[srcIndexB];// transposed
        barrier();

        // Compute
        [[unroll]] for (uint iterBK = 0; iterBK < BLOCK_TILE_K; iterBK++) {
            const float valA = sharedA[localID.y][iterBK];
            const float valB = sharedB[localID.x][iterBK];// transposed
            acc = fma(valA, valB, acc);
        }
        barrier();
    }

    const uint dstIndex = globalID.y * N + globalID.x;
    dstMat[dstIndex] = acc;
}
