// Hide store shared mem to global mem

#version 460

#extension GL_EXT_control_flow_attributes : enable

layout (local_size_x_id = 0, local_size_y_id = 1) in;

layout (binding = 0, std430) readonly buffer SrcMatA { vec4 srcMatA[]; };
layout (binding = 1, std430) readonly buffer SrcMatB { vec4 srcMatB[]; };
layout (binding = 2, std430) writeonly buffer DstMat { vec4 dstMat[]; };

layout (constant_id = 2) const int M = 0;
layout (constant_id = 3) const int N = 0;
layout (constant_id = 4) const int K = 0;
layout (constant_id = 5) const int BLOCK_TILE_M = 128;
layout (constant_id = 6) const int BLOCK_TILE_N = 128;
layout (constant_id = 7) const int BLOCK_TILE_K = 128;

const int THREAD_TILE_M = int(BLOCK_TILE_M / gl_WorkGroupSize.y);
const int THREAD_TILE_N = int(BLOCK_TILE_N / gl_WorkGroupSize.x);
const int THREAD_TILE_N_4 = THREAD_TILE_N / 4;
layout (constant_id = 8) const int THREAD_TILE_K = 8;
layout (constant_id = 9) const int STAGES = 2;

const ivec2 SMEM_EXTENT_A = ivec2(BLOCK_TILE_K / 4, BLOCK_TILE_M);
const ivec2 SMEM_EXTENT_B = ivec2(BLOCK_TILE_N / 4, BLOCK_TILE_K);
shared vec4 sharedA[STAGES][BLOCK_TILE_M][BLOCK_TILE_K / 4];
shared vec4 sharedB[STAGES][BLOCK_TILE_K][BLOCK_TILE_N / 4];

void zeroFillAccumulator(inout vec4 regAccumulator[THREAD_TILE_M][THREAD_TILE_N_4]) {
    [[unroll]] for (int tm = 0; tm < THREAD_TILE_M; tm++) {
        [[unroll]] for (int tn = 0; tn < THREAD_TILE_N_4; tn++) {
            regAccumulator[tm][tn] = vec4(0.0f);
        }
    }
}

void loadGlobalToShared(ivec2 globalCoord, ivec2 globalExtent, int globalRowStride, bool loadA, int stage) {
    const ivec2 groupSize = ivec2(gl_WorkGroupSize.xy);
    const int localIndex = int(gl_LocalInvocationIndex);

    const int groupThreadCount = int(groupSize.x * groupSize.y);
    const int loadsPerThread = globalExtent.x * globalExtent.y / groupThreadCount;

    for (int i = 0; i < loadsPerThread; i++) {
        const int linearIdx = i * groupThreadCount + localIndex;
        const ivec2 srcOffset = ivec2(linearIdx % globalExtent.x, linearIdx / globalExtent.x);
        const ivec2 srcCoord = globalCoord + srcOffset;
        const int srcIndex = srcCoord.y * globalRowStride + srcCoord.x;

        const ivec2 dstCoord = srcOffset;
        if (loadA) {
            sharedA[stage][dstCoord.y][dstCoord.x] = srcMatA[srcIndex];
        } else {
            sharedB[stage][dstCoord.y][dstCoord.x] = srcMatB[srcIndex];
        }
    }
}

void computeWithShared(inout vec4 regAccumulator[THREAD_TILE_M][THREAD_TILE_N_4], int stage) {
    const ivec2 groupSize = ivec2(gl_WorkGroupSize.xy);
    const ivec2 localID = ivec2(gl_LocalInvocationID.xy);

    vec4 regA[THREAD_TILE_K / 4];// Only cache one row for row-major A
    vec4 regB[THREAD_TILE_K][THREAD_TILE_N_4];// Cache the whole B

    const int threadSplitKCount = BLOCK_TILE_K / THREAD_TILE_K;
    for (int iThreadSplitK = 0; iThreadSplitK < threadSplitKCount; iThreadSplitK++) {
        // Load B
        [[unroll]] for (int tk = 0; tk < THREAD_TILE_K; tk++) {
            const int sharedCoordY = iThreadSplitK * THREAD_TILE_K + tk;
            [[unroll]] for (int tn = 0; tn < THREAD_TILE_N_4; tn++) {
                const int sharedCoordX = tn * groupSize.x + localID.x;
                regB[tk][tn] = sharedB[stage][sharedCoordY][sharedCoordX];
            }
        }

        // For each row in A
        [[unroll]] for (int tm = 0; tm < THREAD_TILE_M; tm++) {
            // Load A
            const int sharedCoordY = tm * groupSize.y + localID.y;
            [[unroll]] for (int tk = 0; tk < THREAD_TILE_K / 4; tk++) {
                const int sharedCoordX = iThreadSplitK * THREAD_TILE_K + tk;
                regA[tk] = sharedA[stage][sharedCoordY][sharedCoordX];
            }

            // Actual compute
            [[unroll]] for (int tn = 0; tn < THREAD_TILE_N_4; tn++) {
                [[unroll]] for (int tk = 0; tk < THREAD_TILE_K / 4; tk++) {
                    regAccumulator[tm][tn] += regA[tk].x * regB[tk * 4 + 0][tn];
                    regAccumulator[tm][tn] += regA[tk].y * regB[tk * 4 + 1][tn];
                    regAccumulator[tm][tn] += regA[tk].z * regB[tk * 4 + 2][tn];
                    regAccumulator[tm][tn] += regA[tk].w * regB[tk * 4 + 3][tn];
                }
            }
        }
    }
}

void storeAccumulator(inout vec4 regAccumulator[THREAD_TILE_M][THREAD_TILE_N_4], ivec2 blockID) {
    const ivec2 groupSize = ivec2(gl_WorkGroupSize.xy);
    const ivec2 localID = ivec2(gl_LocalInvocationID.xy);

    const ivec2 globalCoordBase = ivec2(blockID.x * BLOCK_TILE_N / 4, blockID.y * BLOCK_TILE_M);
    [[unroll]] for (int tm = 0; tm < THREAD_TILE_M; tm++) {
        [[unroll]] for (int tn = 0; tn < THREAD_TILE_N_4; tn++) {
            const int globalCoordY = globalCoordBase.y + tm * groupSize.y + localID.y;
            const int globalCoordX = globalCoordBase.x + tn * groupSize.x + localID.x;
            const int dstIdx = globalCoordY * N / 4 + globalCoordX;
            dstMat[dstIdx] = regAccumulator[tm][tn];
        }
    }
}

void computeBlock(ivec2 blockID, inout int stage) {
    // Accumulator
    vec4 regAccumulator[THREAD_TILE_M][THREAD_TILE_N_4];
    zeroFillAccumulator(regAccumulator);

    // Main-loop
    const int blockBaseM = blockID.y * BLOCK_TILE_M;
    const int blockBaseN = blockID.x * BLOCK_TILE_N;
    const int blockSplitKCount = K / BLOCK_TILE_K;
    for (int iBlockSplitK = 1; iBlockSplitK < blockSplitKCount; iBlockSplitK++) {
        const int nextStage = (stage + 1) % STAGES;
        const int blockBaseK = iBlockSplitK * BLOCK_TILE_K;

        const ivec2 globalCoordA = ivec2(blockBaseK / 4, blockBaseM);
        loadGlobalToShared(globalCoordA, SMEM_EXTENT_A, K / 4, true, nextStage);// Load A

        const ivec2 globalCoordB = ivec2(blockBaseN / 4, blockBaseK);
        loadGlobalToShared(globalCoordB, SMEM_EXTENT_B, N / 4, false, nextStage);// Load B

        computeWithShared(regAccumulator, stage);

        stage = nextStage;
        barrier();
    }

    // Epilogue
    computeWithShared(regAccumulator, stage);

    // Store results
    storeAccumulator(regAccumulator, blockID);
}

void main() {
    const int groupCount = int(gl_NumWorkGroups.x);
    const int groupIndex = int(gl_WorkGroupID.x);
    const ivec2 blockCount = ivec2(N / BLOCK_TILE_N, M / BLOCK_TILE_M);
    const int blockPerGroup = (blockCount.x * blockCount.y + groupCount - 1) / groupCount;

    // Prologue
    int stage = 0;
    ivec2 blockID = ivec2(groupIndex % blockCount.x, groupIndex / blockCount.x);

    const ivec2 globalCoordA = ivec2(0, blockID.y * BLOCK_TILE_M);
    loadGlobalToShared(globalCoordA, SMEM_EXTENT_A, K / 4, true, 0);// Load A

    const ivec2 globalCoordB = ivec2(blockID.x * BLOCK_TILE_N / 4, 0);
    loadGlobalToShared(globalCoordB, SMEM_EXTENT_B, N / 4, false, 0);// Load B
    barrier();

    for (int iBlock = 1; iBlock < blockPerGroup; iBlock++) {
        computeBlock(blockID, stage);

        // Load next block
        const int nextBlockIndex = iBlock * groupCount + groupIndex;
        const int nextStage = (stage + 1) % STAGES;
        if (nextBlockIndex >= blockCount.x * blockCount.y) {
            break;
        }
        const ivec2 nextBlockID = ivec2(nextBlockIndex % blockCount.x, nextBlockIndex / blockCount.x);

        const ivec2 globalCoordA = ivec2(0, nextBlockID.y * BLOCK_TILE_M);
        loadGlobalToShared(globalCoordA, SMEM_EXTENT_A, K / 4, true, nextStage);// Load A

        const ivec2 globalCoordB = ivec2(nextBlockID.x * BLOCK_TILE_N / 4, 0);
        loadGlobalToShared(globalCoordB, SMEM_EXTENT_B, N / 4, false, nextStage);// Load B

        blockID = nextBlockID;
        stage = nextStage;
        barrier();
    }

    computeBlock(blockID, stage);
}
