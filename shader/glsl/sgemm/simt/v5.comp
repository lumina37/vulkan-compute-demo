// Resolve SMEM bank-conflict

#version 460

#extension GL_EXT_control_flow_attributes : enable

layout (local_size_x_id = 0, local_size_y_id = 1) in;

layout (binding = 0, std430) readonly buffer SrcMatA { vec4 srcMatA[]; };
layout (binding = 1, std430) readonly buffer SrcMatB { vec4 srcMatB[]; };
layout (binding = 2, std430) writeonly buffer DstMat { vec4 dstMat[]; };

layout (constant_id = 2) const uint M = 0;
layout (constant_id = 3) const uint N = 0;
layout (constant_id = 4) const uint K = 0;
layout (constant_id = 5) const uint BLOCK_TILE_M = 128;
layout (constant_id = 6) const uint BLOCK_TILE_N = 128;
layout (constant_id = 7) const uint BLOCK_TILE_K = 32;
layout (constant_id = 8) const uint THREAD_TILE_M = 16;
layout (constant_id = 9) const uint THREAD_TILE_N = 16;
layout (constant_id = 10) const uint THREAD_TILE_K = 16;
const uint BLOCK_TILE_VEC_N = BLOCK_TILE_N / 4;
const uint BLOCK_TILE_VEC_K = BLOCK_TILE_K / 4;
const uint THREAD_TILE_VEC_N = THREAD_TILE_N / 4;
const uint THREAD_TILE_VEC_K = THREAD_TILE_K / 4;

const uvec2 SHARED_EXTENT_A = uvec2(BLOCK_TILE_VEC_K, BLOCK_TILE_M);
const uvec2 SHARED_EXTENT_B = uvec2(BLOCK_TILE_VEC_N, BLOCK_TILE_K);
shared vec4 sharedA[BLOCK_TILE_M][BLOCK_TILE_VEC_K];
shared vec4 sharedB[BLOCK_TILE_K][BLOCK_TILE_VEC_N];

void zeroFillAccumulator(inout vec4 regAccumulator[THREAD_TILE_M][THREAD_TILE_VEC_N]) {
    [[unroll]] for (uint iterTM = 0; iterTM < THREAD_TILE_M; iterTM++) {
        [[unroll]] for (uint iterVecTN = 0; iterVecTN < THREAD_TILE_VEC_N; iterVecTN++) {
            regAccumulator[iterTM][iterVecTN] = vec4(0);
        }
    }
}

void loadGlobalToShared(uvec2 globalCoord, uvec2 globalExtent, uint globalRowStride, bool loadA) {
    const uvec2 groupSize = gl_WorkGroupSize.xy;
    const uint localIndex = gl_LocalInvocationIndex;

    const uint groupThreadCount = groupSize.x * groupSize.y;
    const uint loadsPerThread = globalExtent.x * globalExtent.y / groupThreadCount;

    for (uint i = 0; i < loadsPerThread; i++) {
        const uint linearIdx = i * groupThreadCount + localIndex;
        const uvec2 srcOffset = uvec2(linearIdx % globalExtent.x, linearIdx / globalExtent.x);
        const uvec2 srcCoord = globalCoord + srcOffset;
        const uint srcIndex = srcCoord.y * globalRowStride + srcCoord.x;

        const uvec2 dstCoord = srcOffset;
        if (loadA) {
            sharedA[dstCoord.y][dstCoord.x] = srcMatA[srcIndex];
        } else {
            sharedB[dstCoord.y][dstCoord.x] = srcMatB[srcIndex];
        }
    }
}

void computeWithShared(inout vec4 regAccumulator[THREAD_TILE_M][THREAD_TILE_VEC_N]) {
    const uvec2 groupSize = gl_WorkGroupSize.xy;
    const uvec2 localID = gl_LocalInvocationID.xy;

    vec4 regA[THREAD_TILE_VEC_K];// Only cache one row for row-major A
    vec4 regB[THREAD_TILE_K][THREAD_TILE_VEC_N];// Cache the whole B

    [[unroll]] for (uint iterBK = 0; iterBK < BLOCK_TILE_K; iterBK += THREAD_TILE_K) {
        // Load B
        [[unroll]] for (uint iterTK = 0; iterTK < THREAD_TILE_K; iterTK++) {
            const uint sharedCoordKB = iterBK + iterTK;
            [[unroll]] for (uint iterVecTN = 0; iterVecTN < THREAD_TILE_VEC_N; iterVecTN++) {
                const uint sharedCoordVecNB = iterVecTN * groupSize.x + localID.x;
                regB[iterTK][iterVecTN] = sharedB[sharedCoordKB][sharedCoordVecNB];
            }
        }

        // For each row in A
        [[unroll]] for (uint iterTM = 0; iterTM < THREAD_TILE_M; iterTM++) {
            // Load A
            const uint sharedCoordMA = iterTM * groupSize.y + localID.y;
            [[unroll]] for (uint iterVecTK = 0; iterVecTK < THREAD_TILE_VEC_K; iterVecTK++) {
                const uint sharedCoordVecKA = iterBK / 4 + iterVecTK;
                regA[iterVecTK] = sharedA[sharedCoordMA][sharedCoordVecKA];
            }

            // Actual compute
            [[unroll]] for (uint iterVecTN = 0; iterVecTN < THREAD_TILE_VEC_N; iterVecTN++) {
                [[unroll]] for (uint iterVecTK = 0; iterVecTK < THREAD_TILE_VEC_K; iterVecTK++) {
                    const uint regBaseKB = iterVecTK * 4;
                    regAccumulator[iterTM][iterVecTN] += regA[iterVecTK].x * regB[regBaseKB + 0][iterVecTN];
                    regAccumulator[iterTM][iterVecTN] += regA[iterVecTK].y * regB[regBaseKB + 1][iterVecTN];
                    regAccumulator[iterTM][iterVecTN] += regA[iterVecTK].z * regB[regBaseKB + 2][iterVecTN];
                    regAccumulator[iterTM][iterVecTN] += regA[iterVecTK].w * regB[regBaseKB + 3][iterVecTN];
                }
            }
        }
    }
}

void storeAccumulator(vec4 regAccumulator[THREAD_TILE_M][THREAD_TILE_VEC_N]) {
    const uvec2 groupID = gl_WorkGroupID.xy;
    const uvec2 groupSize = gl_WorkGroupSize.xy;
    const uvec2 localID = gl_LocalInvocationID.xy;

    const uint globalBaseM = groupID.y * BLOCK_TILE_M + localID.y;
    const uint globalBaseVecN = groupID.x * BLOCK_TILE_VEC_N + localID.x;
    [[unroll]] for (uint iterTM = 0; iterTM < THREAD_TILE_M; iterTM++) {
        const uint globalCoordM = globalBaseM + iterTM * groupSize.y;
        [[unroll]] for (uint iterVecTN = 0; iterVecTN < THREAD_TILE_VEC_N; iterVecTN++) {
            const uint globalCoordVecN = globalBaseVecN + iterVecTN * groupSize.x;
            const uint dstIdx = globalCoordM * N / 4 + globalCoordVecN;
            dstMat[dstIdx] = regAccumulator[iterTM][iterVecTN];
        }
    }
}

void main() {
    const uvec2 groupID = gl_WorkGroupID.xy;

    // Accumulator
    vec4 regAccumulator[THREAD_TILE_M][THREAD_TILE_VEC_N];
    zeroFillAccumulator(regAccumulator);

    // Main-loop
    const uint blockBaseM = groupID.y * BLOCK_TILE_M;
    const uint blockBaseVecN = groupID.x * BLOCK_TILE_VEC_N;
    [[unroll]] for (uint iterK = 0; iterK < K; iterK += BLOCK_TILE_K) {
        const uvec2 globalCoordA = uvec2(iterK / 4, blockBaseM);
        loadGlobalToShared(globalCoordA, SHARED_EXTENT_A, K / 4, true);// Load A

        const uvec2 globalCoordB = uvec2(blockBaseVecN, iterK);
        loadGlobalToShared(globalCoordB, SHARED_EXTENT_B, N / 4, false);// Load B
        barrier();

        computeWithShared(regAccumulator);
        barrier();
    }

    // Store results
    storeAccumulator(regAccumulator);
}
