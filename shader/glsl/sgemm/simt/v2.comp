// Thread-tile with Shared Memory

#version 460

#extension GL_EXT_control_flow_attributes : enable

layout (local_size_x_id = 0, local_size_y_id = 1) in;

layout (binding = 0, std430) readonly buffer SrcMatA { float srcMatA[]; };
layout (binding = 1, std430) readonly buffer SrcMatB { float srcMatB[]; };
layout (binding = 2, std430) writeonly buffer DstMat { float dstMat[]; };

layout (constant_id = 2) const uint M = 0;
layout (constant_id = 3) const uint N = 0;
layout (constant_id = 4) const uint K = 0;
layout (constant_id = 5) const uint BLOCK_TILE_M = 128;
layout (constant_id = 6) const uint BLOCK_TILE_N = 128;
layout (constant_id = 7) const uint BLOCK_TILE_K = 128;
layout (constant_id = 8) const uint THREAD_TILE_M = 16;
layout (constant_id = 9) const uint THREAD_TILE_N = 16;

const uvec2 SHARED_EXTENT_A = uvec2(BLOCK_TILE_K, BLOCK_TILE_M);
const uvec2 SHARED_EXTENT_B = uvec2(BLOCK_TILE_N, BLOCK_TILE_K);
shared float sharedA[BLOCK_TILE_M][BLOCK_TILE_K];
shared float sharedB[BLOCK_TILE_N][BLOCK_TILE_K];

void zeroFillAccumulator(inout float regAccumulator[THREAD_TILE_M][THREAD_TILE_N]) {
    [[unroll]] for (uint tm = 0; tm < THREAD_TILE_M; tm++) {
        [[unroll]] for (uint tn = 0; tn < THREAD_TILE_N; tn++) {
            regAccumulator[tm][tn] = 0.f;
        }
    }
}

void loadGlobalToShared(uvec2 globalCoord, uvec2 globalExtent, uint globalRowStride, bool transposed, bool loadA) {
    const uvec2 groupSize = gl_WorkGroupSize.xy;
    const uint localIndex = gl_LocalInvocationIndex;

    const uint groupThreadCount = groupSize.x * groupSize.y;
    const uint loadsPerThread = globalExtent.x * globalExtent.y / groupThreadCount;

    for (uint i = 0; i < loadsPerThread; i++) {
        const uint linearIdx = i * groupThreadCount + localIndex;
        const uvec2 srcOffset = uvec2(linearIdx % globalExtent.x, linearIdx / globalExtent.x);
        const uvec2 srcCoord = globalCoord + srcOffset;
        const uint srcIndex = srcCoord.y * globalRowStride + srcCoord.x;

        uvec2 dstCoord;
        if (transposed) {
            dstCoord = srcOffset.yx;
        } else {
            dstCoord = srcOffset;
        }

        if (loadA) {
            sharedA[dstCoord.y][dstCoord.x] = srcMatA[srcIndex];
        } else {
            sharedB[dstCoord.y][dstCoord.x] = srcMatB[srcIndex];
        }
    }
}

void computeWithShared(inout float regAccumulator[THREAD_TILE_M][THREAD_TILE_N]) {
    const uvec2 localID = gl_LocalInvocationID.xy;

    [[unroll]] for (uint tm = 0; tm < THREAD_TILE_M; tm++) {
        const uint yA = localID.y * THREAD_TILE_M + tm;
        [[unroll]] for (uint tn = 0; tn < THREAD_TILE_N; tn++) {
            const uint yB = localID.x * THREAD_TILE_N + tn;
            [[unroll]] for (uint tk = 0; tk < BLOCK_TILE_K; tk++) {
                const float valA = sharedA[yA][tk];
                const float valB = sharedB[yB][tk];
                regAccumulator[tm][tn] = fma(valA, valB, regAccumulator[tm][tn]);
            }
        }
    }
}

void storeAccumulator(float regAccumulator[THREAD_TILE_M][THREAD_TILE_N]) {
    const uvec2 globalID = gl_GlobalInvocationID.xy;

    [[unroll]] for (uint tm = 0; tm < THREAD_TILE_M; tm++) {
        [[unroll]] for (uint tn = 0; tn < THREAD_TILE_N; tn++) {
            const uint globalCoordY = globalID.y * THREAD_TILE_M + tm;
            const uint globalCoordX = globalID.x * THREAD_TILE_N + tn;
            const uint dstIdx = globalCoordY * N + globalCoordX;
            dstMat[dstIdx] = regAccumulator[tm][tn];
        }
    }
}

void main() {
    const uvec2 groupID = gl_WorkGroupID.xy;

    // Accumulator
    float regAccumulator[THREAD_TILE_M][THREAD_TILE_N];
    zeroFillAccumulator(regAccumulator);

    // Main-loop
    const uint blockBaseM = groupID.y * BLOCK_TILE_M;
    const uint blockBaseN = groupID.x * BLOCK_TILE_N;
    const uint blockSplitKCount = K / BLOCK_TILE_K;
    for (uint iBlockSplitK = 0; iBlockSplitK < blockSplitKCount; iBlockSplitK++) {
        const uint blockBaseK = iBlockSplitK * BLOCK_TILE_K;
        const uvec2 globalCoordA = uvec2(blockBaseK, blockBaseM);
        loadGlobalToShared(globalCoordA, SHARED_EXTENT_A, K, false, true);// Load A without transpose

        const uvec2 globalCoordB = uvec2(blockBaseN, blockBaseK);
        loadGlobalToShared(globalCoordB, SHARED_EXTENT_B, N, true, false);// Load B with transpose
        barrier();

        computeWithShared(regAccumulator);
        barrier();
    }

    // Store results
    storeAccumulator(regAccumulator);
}
