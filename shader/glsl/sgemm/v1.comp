#version 460

layout (local_size_x_id = 0, local_size_y_id = 0) in;

layout (binding = 0, r32f) uniform readonly image2D srcMatA;
layout (binding = 1, r32f) uniform readonly image2D srcMatB;
layout (binding = 2, r32f) uniform writeonly image2D dstMat;

layout (constant_id = 1) const int K = 0;

shared float sharedA[gl_WorkGroupSize.y][gl_WorkGroupSize.x];
shared float sharedB[gl_WorkGroupSize.x][gl_WorkGroupSize.y];

void main() {
    const ivec2 globalID = ivec2(gl_GlobalInvocationID.xy);
    const ivec2 dstSize = imageSize(dstMat);
    if (globalID.x >= dstSize.x || globalID.y >= dstSize.y) {
        return;
    }
    const ivec2 groupSize = ivec2(gl_WorkGroupSize.xy);
    const ivec2 localID = ivec2(gl_LocalInvocationID.xy);

    const ivec2 sizeA = imageSize(srcMatA);// M * K
    const ivec2 sizeB = imageSize(srcMatB);// K * N
    const int M = sizeA.y;// height on the left
    const int N = sizeB.x;// width at the top

    float acc = 0.0;
    const int tileCount = K / groupSize.x;
    for (int iTile = 0; iTile < tileCount; iTile++) {
        // Load from srcMatA
        const int srcX = iTile * groupSize.x + localID.x;
        const ivec2 srcACoord = ivec2(srcX, globalID.y);
        const vec4 srcAVal = imageLoad(srcMatA, srcACoord);
        sharedA[localID.y][localID.x] = srcAVal.r;

        // Load from srcMatB
        const int srcY = iTile * groupSize.y + localID.y;
        const ivec2 srcBCoord = ivec2(globalID.x, srcY);
        const vec4 srcBVal = imageLoad(srcMatB, srcBCoord);
        sharedB[localID.x][localID.y] = srcBVal.r;// transposed
        barrier();

        // Compute
        for (int iK = 0; iK < groupSize.x; iK++) {
            const float valA = sharedA[localID.y][iK];
            const float valB = sharedB[localID.x][iK];// transposed
            acc += valA * valB;
        }
        barrier();
    }

    const vec4 dstVal = vec4(acc, 0.0, 0.0, 0.0);
    imageStore(dstMat, globalID, dstVal);
}
