#version 460

#extension GL_EXT_control_flow_attributes : enable

layout (local_size_x_id = 0, local_size_y_id = 1) in;

layout (binding = 0, std430) readonly buffer SrcMatA { float srcMatA[]; };
layout (binding = 1, std430) readonly buffer SrcMatB { float srcMatB[]; };
layout (binding = 2, std430) writeonly buffer DstMat { float dstMat[]; };

layout (constant_id = 2) const int M = 0;
layout (constant_id = 3) const int N = 0;
layout (constant_id = 4) const int K = 0;

shared float sharedA[gl_WorkGroupSize.y][gl_WorkGroupSize.x];
shared float sharedB[gl_WorkGroupSize.x][gl_WorkGroupSize.y];

void main() {
    const ivec2 globalID = ivec2(gl_GlobalInvocationID.xy);
    if (globalID.x >= N || globalID.y >= M) {
        return;
    }
    const ivec2 groupSize = ivec2(gl_WorkGroupSize.xy);
    const ivec2 localID = ivec2(gl_LocalInvocationID.xy);

    float acc = 0.0;
    const int tileCount = K / groupSize.x;
    for (int iTile = 0; iTile < tileCount; iTile++) {
        // Load from srcMatA
        const int srcX = iTile * groupSize.x + localID.x;
        const int srcAIndex = globalID.y * K + srcX;
        sharedA[localID.y][localID.x] = srcMatA[srcAIndex];

        // Load from srcMatB
        const int srcY = iTile * groupSize.y + localID.y;
        const int srcBIndex = srcY * N + globalID.x;
        sharedB[localID.x][localID.y] = srcMatB[srcBIndex];// transposed
        barrier();

        // Compute
        [[unroll]] for (int k = 0; k < groupSize.x; k++) {
            const float valA = sharedA[localID.y][k];
            const float valB = sharedB[localID.x][k];// transposed
            acc += valA * valB;
        }
        barrier();
    }

    const int dstIndex = globalID.y * N + globalID.x;
    dstMat[dstIndex] = acc;
}
