#version 460

#extension GL_EXT_shader_16bit_storage: require
#extension GL_EXT_shader_explicit_arithmetic_types_float16: require
#extension GL_KHR_memory_scope_semantics: require
#extension GL_KHR_cooperative_matrix: require

layout (local_size_x_id = 0) in;

layout (binding = 0, std430) readonly buffer SrcMatA { float srcMatA[]; };
layout (binding = 1, std430) readonly buffer SrcMatB { float srcMatB[]; };
layout (binding = 2, std430) writeonly buffer DstMat { float dstMat[]; };

layout (constant_id = 1) const int M = 0;
layout (constant_id = 2) const int N = 0;
layout (constant_id = 3) const int K = 0;
const int MMA_M = 16;
const int MMA_N = 16;
const int MMA_K = 16;

shared float16_t sharedA[MMA_M * MMA_K];
shared float16_t sharedB[MMA_K * MMA_N];
shared float sharedC[MMA_M * MMA_N];

void main() {
    const int groupSize = int(gl_WorkGroupSize.x);
    const ivec2 localID = ivec2(gl_LocalInvocationID.xy);
    const ivec2 groupID = ivec2(gl_WorkGroupID.xy);

    coopmat<float16_t, gl_ScopeSubgroup, MMA_M, MMA_K, gl_MatrixUseA> matA;
    coopmat<float16_t, gl_ScopeSubgroup, MMA_K, MMA_N, gl_MatrixUseB> matB;
    coopmat<float, gl_ScopeSubgroup, MMA_M, MMA_N, gl_MatrixUseAccumulator> matAcc;
    matAcc = coopmat<float, gl_ScopeSubgroup, MMA_M, MMA_N, gl_MatrixUseAccumulator>(0.0);

    const int blockTileCount = K / MMA_K;
    const int baseM = groupID.y * MMA_M;
    const int baseN = groupID.x * MMA_N;
    for (int iBlkTile = 0; iBlkTile < blockTileCount; iBlkTile++) {
        const int baseK = iBlkTile * MMA_K;
        const int loadsPerThreadA = MMA_M * MMA_K / groupSize;
        for (int i = 0; i < loadsPerThreadA; i++) {
            const int linearIdx = localID.x * loadsPerThreadA + i;
            const int srcX = baseK + linearIdx % MMA_K;
            const int srcY = baseM + linearIdx / MMA_K;
            const int srcAIndex = srcY * K + srcX;
            sharedA[linearIdx] = float16_t(srcMatA[srcAIndex]);
        }

        const int loadsPerThreadB = MMA_K * MMA_N / groupSize;
        for (int i = 0; i < loadsPerThreadB; i++) {
            const int linearIdx = localID.x * loadsPerThreadB + i;
            const int srcX = baseN + linearIdx % MMA_N;
            const int srcY = baseK + linearIdx / MMA_N;
            const int srcBIndex = srcY * N + srcX;
            sharedB[linearIdx] = float16_t(srcMatB[srcBIndex]);
        }
        barrier();

        coopMatLoad(matA, sharedA, 0, MMA_K, gl_CooperativeMatrixLayoutRowMajor);
        coopMatLoad(matB, sharedB, 0, MMA_N, gl_CooperativeMatrixLayoutRowMajor);
        matAcc = coopMatMulAdd(matA, matB, matAcc);
        barrier();
    }

    coopMatStore(matAcc, sharedC, 0, MMA_N, gl_CooperativeMatrixLayoutRowMajor);
    barrier();

    int storesPerThread = MMA_M * MMA_N / groupSize;
    for (int i = 0; i < storesPerThread; i++) {
        const int linearIdx = localID.x * storesPerThread + i;
        const int dstX = baseN + linearIdx % MMA_K;
        const int dstY = baseM + linearIdx / MMA_K;
        const int dstIndex = dstY * N + dstX;
        dstMat[dstIndex] = sharedC[linearIdx];
    }
}
