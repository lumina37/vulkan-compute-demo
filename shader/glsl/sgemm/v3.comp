#version 460

#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_memory_scope_semantics : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : enable
#extension GL_KHR_cooperative_matrix : enable

layout (local_size_x = 32, local_size_y = 1) in;

layout (binding = 0, r32f) uniform readonly image2D srcMatA;
layout (binding = 1, r32f) uniform readonly image2D srcMatB;
layout (binding = 2, r32f) uniform writeonly image2D dstMat;

layout (constant_id = 1) const int K = 0;

shared float16_t sharedA[16 * 16];
shared float16_t sharedB[16 * 16];
shared float sharedC[16 * 16];

void main() {
    const ivec2 sizeA = imageSize(srcMatA);
    const ivec2 sizeB = imageSize(srcMatB);

    const int M = sizeA.y;
    const int N = sizeB.x;

    const int MMA_M = 16;
    const int MMA_N = 16;
    const int MMA_K = 16;

    int mmaTilesN = (N + MMA_N - 1) / MMA_N;
    int mmaTilesM = (M + MMA_M - 1) / MMA_M;

    int mmaTileM = int(gl_WorkGroupID.x) / mmaTilesN;
    int mmaTileN = int(gl_WorkGroupID.x) % mmaTilesN;

    if (mmaTileM >= mmaTilesM || mmaTileN >= mmaTilesN) {
        return;
    }

    coopmat<float16_t, gl_ScopeSubgroup, MMA_M, MMA_K, gl_MatrixUseA> matA;
    coopmat<float16_t, gl_ScopeSubgroup, MMA_K, MMA_N, gl_MatrixUseB> matB;
    coopmat<float, gl_ScopeSubgroup, MMA_M, MMA_N, gl_MatrixUseAccumulator> matAcc;
    matAcc = coopmat<float, gl_ScopeSubgroup, MMA_M, MMA_N, gl_MatrixUseAccumulator>(0.0);

    int blockTileCount = (K + MMA_K - 1) / MMA_K;
    for (int iBlkTile = 0; iBlkTile < blockTileCount; iBlkTile++) {
        int baseRowA = mmaTileM * MMA_M;
        int baseColA = iBlkTile * MMA_K;
        int baseRowB = iBlkTile * MMA_K;
        int baseColB = mmaTileN * MMA_N;

        uint elementsPerThread = (MMA_M * MMA_K + gl_WorkGroupSize.x - 1) / gl_WorkGroupSize.x;
        for (uint i = 0; i < elementsPerThread; i++) {
            uint linearIdx = gl_LocalInvocationID.x * elementsPerThread + i;
            if (linearIdx < MMA_M * MMA_K) {
                uint row = linearIdx / MMA_K;
                uint col = linearIdx % MMA_K;

                int globalRow = baseRowA + int(row);
                int globalCol = baseColA + int(col);

                float16_t value = float16_t(0.0);
                if (globalRow < M && globalCol < K) {
                    vec4 texel = imageLoad(srcMatA, ivec2(globalCol, globalRow));
                    value = float16_t(texel.r);
                }
                sharedA[linearIdx] = value;
            }
        }

        elementsPerThread = (MMA_K * MMA_N + gl_WorkGroupSize.x - 1) / gl_WorkGroupSize.x;
        for (uint i = 0; i < elementsPerThread; i++) {
            uint linearIdx = gl_LocalInvocationID.x * elementsPerThread + i;
            if (linearIdx < MMA_K * MMA_N) {
                uint row = linearIdx / MMA_N;
                uint col = linearIdx % MMA_N;

                int globalRow = baseRowB + int(row);
                int globalCol = baseColB + int(col);

                float16_t value = float16_t(0.0);
                if (globalRow < K && globalCol < N) {
                    vec4 texel = imageLoad(srcMatB, ivec2(globalCol, globalRow));
                    value = float16_t(texel.r);
                }
                sharedB[linearIdx] = value;
            }
        }
        barrier();

        coopMatLoad(matA, sharedA, 0, MMA_K, gl_CooperativeMatrixLayoutRowMajor);
        coopMatLoad(matB, sharedB, 0, MMA_N, gl_CooperativeMatrixLayoutRowMajor);
        matAcc = coopMatMulAdd(matA, matB, matAcc);
        barrier();
    }

    coopMatStore(matAcc, sharedC, 0, MMA_N, gl_CooperativeMatrixLayoutRowMajor);
    barrier();

    int baseRowC = mmaTileM * MMA_M;
    int baseColC = mmaTileN * MMA_N;

    uint elementsPerThread = (MMA_M * MMA_N + gl_WorkGroupSize.x - 1) / gl_WorkGroupSize.x;
    for (uint i = 0; i < elementsPerThread; i++) {
        uint linearIdx = gl_LocalInvocationID.x * elementsPerThread + i;
        if (linearIdx < MMA_M * MMA_N) {
            uint row = linearIdx / MMA_N;
            uint col = linearIdx % MMA_N;

            int globalRow = baseRowC + int(row);
            int globalCol = baseColC + int(col);

            if (globalRow < M && globalCol < N) {
                float result = sharedC[linearIdx];
                imageStore(dstMat, ivec2(globalCol, globalRow), vec4(result, 0.0, 0.0, 0.0));
            }
        }
    }
}