#version 460

#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_memory_scope_semantics : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : enable
#extension GL_KHR_cooperative_matrix : enable

layout (local_size_x = 32, local_size_y = 1) in;

layout (binding = 0, r32f) uniform readonly image2D srcMatA;
layout (binding = 1, r32f) uniform readonly image2D srcMatB;
layout (binding = 2, r32f) uniform writeonly image2D dstMat;

layout (constant_id = 1) const int K = 0;

void main() {
    const ivec2 sizeA = imageSize(srcMatA);
    const ivec2 sizeB = imageSize(srcMatB);

    const int M = sizeA.y;
    const int N = sizeB.x;

    const int MMA_M = 16;
    const int MMA_N = 16;
    const int MMA_K = 16;

    int mmaTilesN = (N + MMA_N - 1) / MMA_N;
    int mmaTilesM = (M + MMA_M - 1) / MMA_M;

    int mmaTileM = int(gl_WorkGroupID.x) / mmaTilesN;
    int mmaTileN = int(gl_WorkGroupID.x) % mmaTilesN;

    if (mmaTileM >= mmaTilesM || mmaTileN >= mmaTilesN) {
        return;
    }

    coopmat<float16_t, gl_ScopeSubgroup, MMA_M, MMA_K, gl_MatrixUseA> matA;
    coopmat<float16_t, gl_ScopeSubgroup, MMA_K, MMA_N, gl_MatrixUseB> matB;
    coopmat<float, gl_ScopeSubgroup, MMA_M, MMA_N, gl_MatrixUseAccumulator> matAcc;

    for (uint i = 0; i < matAcc.length(); i++) {
        matAcc[i] = 0.0;
    }

    int blockTileCount = (K + MMA_K - 1) / MMA_K;
    for (int iBlkTile = 0; iBlkTile < blockTileCount; iBlkTile++) {

        int baseRowA = mmaTileM * MMA_M;
        int baseColA = iBlkTile * MMA_K;
        int baseRowB = iBlkTile * MMA_K;
        int baseColB = mmaTileN * MMA_N;

        for (uint i = 0; i < matA.length(); ++i) {
            if (gl_SubgroupInvocationID == i % gl_SubgroupSize) {

                uint row = i / MMA_K;
                uint col = i % MMA_K;

                int globalRow = baseRowA + int(row);
                int globalCol = baseColA + int(col);

                float16_t value = float16_t(0.0);
                if (globalRow < M && globalCol < K) {
                    vec4 texel = imageLoad(srcMatA, ivec2(globalCol, globalRow));
                    value = float16_t(texel.r);
                }
                matA[i] = value;
            }
        }

        for (uint i = 0; i < matB.length(); ++i) {
            if (gl_SubgroupInvocationID == i % gl_SubgroupSize) {

                uint row = i / MMA_N;
                uint col = i % MMA_N;

                int globalRow = baseRowB + int(row);
                int globalCol = baseColB + int(col);

                float16_t value = float16_t(0.0);
                if (globalRow < K && globalCol < N) {
                    vec4 texel = imageLoad(srcMatB, ivec2(globalCol, globalRow));
                    value = float16_t(texel.r);
                }
                matB[i] = value;
            }
        }
        subgroupBarrier();

        matAcc = coopMatMulAdd(matA, matB, matAcc);
        subgroupBarrier();
    }

    int baseRowC = mmaTileM * MMA_M;
    int baseColC = mmaTileN * MMA_N;

    for (uint i = 0; i < matAcc.length(); ++i) {
        if (gl_SubgroupInvocationID == i % gl_SubgroupSize) {

            uint row = i / MMA_N;
            uint col = i % MMA_N;

            int globalRow = baseRowC + int(row);
            int globalCol = baseColC + int(col);

            if (globalRow < M && globalCol < N) {
                float result = matAcc[i];
                imageStore(dstMat, ivec2(globalCol, globalRow), vec4(result, 0.0, 0.0, 0.0));
            }
        }
    }
}