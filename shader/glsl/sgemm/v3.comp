// Thread-tile with Registers

#version 460

#extension GL_EXT_control_flow_attributes : enable

layout (local_size_x_id = 0, local_size_y_id = 1) in;

layout (binding = 0, std430) readonly buffer SrcMatA { float srcMatA[]; };
layout (binding = 1, std430) readonly buffer SrcMatB { float srcMatB[]; };
layout (binding = 2, std430) writeonly buffer DstMat { float dstMat[]; };

layout (constant_id = 2) const int M = 0;
layout (constant_id = 3) const int N = 0;
layout (constant_id = 4) const int K = 0;
layout (constant_id = 5) const int BLOCK_TILE_M = 128;
layout (constant_id = 6) const int BLOCK_TILE_N = 128;
layout (constant_id = 7) const int BLOCK_TILE_K = 128;

const int THREAD_TILE_M = int(BLOCK_TILE_M / gl_WorkGroupSize.y);
const int THREAD_TILE_N = int(BLOCK_TILE_N / gl_WorkGroupSize.x);
layout (constant_id = 8) const int THREAD_TILE_K = 8;

shared float sharedA[BLOCK_TILE_M][BLOCK_TILE_K];
shared float sharedB[BLOCK_TILE_K][BLOCK_TILE_N];

void loadGlobalToShared(ivec2 globalCoord, ivec2 globalExtent, int globalRowStride, bool transposed, bool loadA) {
    const ivec2 groupSize = ivec2(gl_WorkGroupSize.xy);
    const int localIndex = int(gl_LocalInvocationIndex);

    const int groupThreadCount = int(groupSize.x * groupSize.y);
    const int loadsPerThread = globalExtent.x * globalExtent.y / groupThreadCount;

    for (int i = 0; i < loadsPerThread; i++) {
        const int linearIdx = i * groupThreadCount + localIndex;
        const ivec2 srcOffset = ivec2(linearIdx % globalExtent.x, linearIdx / globalExtent.x);
        const ivec2 srcCoord = globalCoord + srcOffset;
        const int srcIndex = srcCoord.y * globalRowStride + srcCoord.x;

        ivec2 dstCoord;
        if (transposed) {
            dstCoord = srcOffset.yx;
        } else {
            dstCoord = srcOffset;
        }

        if (loadA) {
            sharedA[dstCoord.y][dstCoord.x] = srcMatA[srcIndex];
        } else {
            sharedB[dstCoord.y][dstCoord.x] = srcMatB[srcIndex];
        }
    }
}

void main() {
    const ivec2 globalID = ivec2(gl_GlobalInvocationID.xy);
    const ivec2 groupSize = ivec2(gl_WorkGroupSize.xy);
    const ivec2 localID = ivec2(gl_LocalInvocationID.xy);
    const int localIndex = int(gl_LocalInvocationIndex);
    const ivec2 groupID = ivec2(gl_WorkGroupID.xy);
    const int groupThreadCount = groupSize.x * groupSize.y;

    // Accumulation registers for thread tile
    float acc[THREAD_TILE_M][THREAD_TILE_N];
    [[unroll]] for (int tm = 0; tm < THREAD_TILE_M; tm++) {
        [[unroll]] for (int tn = 0; tn < THREAD_TILE_N; tn++) {
            acc[tm][tn] = 0.0;
        }
    }

    const int blockSplitKCount = K / BLOCK_TILE_K;
    for (int iBlockSplitK = 0; iBlockSplitK < blockSplitKCount; iBlockSplitK++) {
        // Load from global to shared
        const ivec2 globalCoordA = ivec2(iBlockSplitK * BLOCK_TILE_K, groupID.y * BLOCK_TILE_M);
        const ivec2 extentA = ivec2(BLOCK_TILE_K, BLOCK_TILE_M);
        loadGlobalToShared(globalCoordA, extentA, K, false, true);// Load A

        const ivec2 globalCoordB = ivec2(groupID.x * BLOCK_TILE_N, iBlockSplitK * BLOCK_TILE_K);
        const ivec2 extentB = ivec2(BLOCK_TILE_N, BLOCK_TILE_K);
        loadGlobalToShared(globalCoordB, extentB, N, false, false);// Load B

        barrier();

        // Compute
        float regA[THREAD_TILE_K];// Only cache one row for row-major A
        float regB[THREAD_TILE_K][THREAD_TILE_N];// Cache the whole B

        const int threadSplitKCount = BLOCK_TILE_K / THREAD_TILE_K;
        for (int iThreadSplitK = 0; iThreadSplitK < threadSplitKCount; iThreadSplitK++) {
            // Load from shared to register

            // Load B
            const ivec2 sharedCoordB = ivec2(localID.x * THREAD_TILE_N, iThreadSplitK * THREAD_TILE_K);
            [[unroll]] for (int tk = 0; tk < THREAD_TILE_K; tk++) {
                [[unroll]] for (int tn = 0; tn < THREAD_TILE_N; tn++) {
                    regB[tk][tn] = sharedB[sharedCoordB.y + tk][sharedCoordB.x + tn];
                }
            }

            // For each row in A
            const ivec2 sharedCoordA = ivec2(iThreadSplitK * THREAD_TILE_K, localID.y * THREAD_TILE_M);
            [[unroll]] for (int tm = 0; tm < THREAD_TILE_M; tm++) {
                // Load A
                [[unroll]] for (int tk = 0; tk < THREAD_TILE_K; tk++) {
                    regA[tk] = sharedA[sharedCoordA.y + tm][sharedCoordA.x + tk];
                }

                // Actual compute
                [[unroll]] for (int tn = 0; tn < THREAD_TILE_N; tn++) {
                    [[unroll]] for (int tk = 0; tk < THREAD_TILE_K; tk++) {
                        acc[tm][tn] += regA[tk] * regB[tk][tn];
                    }
                }
            }
        }
        barrier();
    }

    // Store results
    [[unroll]] for (int tm = 0; tm < THREAD_TILE_M; tm++) {
        [[unroll]] for (int tn = 0; tn < THREAD_TILE_N; tn++) {
            const int globalRow = globalID.y * THREAD_TILE_M + tm;
            const int globalCol = globalID.x * THREAD_TILE_N + tn;
            const int dstIdx = globalRow * N + globalCol;
            dstMat[dstIdx] = acc[tm][tn];
        }
    }
}
