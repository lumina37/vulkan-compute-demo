#version 460

#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_EXT_shader_16bit_storage: require
#extension GL_EXT_shader_explicit_arithmetic_types_float16: require
#extension GL_KHR_memory_scope_semantics: require
#extension GL_KHR_cooperative_matrix: require

layout (local_size_x = 16, local_size_y = 16) in;

layout (binding = 0, r32f) uniform readonly image2D srcMatA;
layout (binding = 1, r32f) uniform readonly image2D srcMatB;
layout (binding = 2, r32f) uniform writeonly image2D dstMat;

layout (constant_id = 0) const int K = 0;

const int MMA_M = 16;
const int MMA_N = 16;
const int MMA_K = 16;

shared float16_t sharedA[16 * 16];
shared float16_t sharedB[16 * 16];
shared float sharedC[16 * 16];

void main() {
    const ivec2 groupSize = ivec2(gl_WorkGroupSize.xy);
    const ivec2 localID = ivec2(gl_LocalInvocationID.xy);
    const ivec2 groupID = ivec2(gl_WorkGroupID.xy);

    const ivec2 sizeA = imageSize(srcMatA);
    const ivec2 sizeB = imageSize(srcMatB);

    const int M = sizeA.y;
    const int N = sizeB.x;

    int mmaTileM = groupID.y;
    int mmaTileN = groupID.x;

    int mmaTilesM = (M + MMA_M - 1) / MMA_M;
    int mmaTilesN = (N + MMA_N - 1) / MMA_N;

    if (mmaTileM >= mmaTilesM || mmaTileN >= mmaTilesN) {
        return;
    }

    coopmat<float16_t, gl_ScopeSubgroup, MMA_M, MMA_K, gl_MatrixUseA> matA;
    coopmat<float16_t, gl_ScopeSubgroup, MMA_K, MMA_N, gl_MatrixUseB> matB;
    coopmat<float, gl_ScopeSubgroup, MMA_M, MMA_N, gl_MatrixUseAccumulator> matAcc;
    matAcc = coopmat<float, gl_ScopeSubgroup, MMA_M, MMA_N, gl_MatrixUseAccumulator>(0.0);

    int blockTileCount = (K + MMA_K - 1) / MMA_K;
    for (int iBlkTile = 0; iBlkTile < blockTileCount; iBlkTile++) {
        int baseRowA = mmaTileM * MMA_M;
        int baseColA = iBlkTile * MMA_K;
        int baseRowB = iBlkTile * MMA_K;
        int baseColB = mmaTileN * MMA_N;

        int loadRowA = baseRowA + localID.y;
        int loadColA = baseColA + localID.x;

        float16_t valueA = float16_t(0.0);
        if (loadRowA < M && loadColA < K) {
            vec4 texel = imageLoad(srcMatA, ivec2(loadColA, loadRowA));
            valueA = float16_t(texel.r);
        }
        sharedA[localID.y * MMA_K + localID.x] = valueA;

        int loadRowB = baseRowB + localID.y;
        int loadColB = baseColB + localID.x;

        float16_t valueB = float16_t(0.0);
        if (loadRowB < K && loadColB < N) {
            vec4 texel = imageLoad(srcMatB, ivec2(loadColB, loadRowB));
            valueB = float16_t(texel.r);
        }
        sharedB[localID.y * MMA_N + localID.x] = valueB;

        barrier();

        coopMatLoad(matA, sharedA, 0, MMA_K, gl_CooperativeMatrixLayoutRowMajor);
        coopMatLoad(matB, sharedB, 0, MMA_N, gl_CooperativeMatrixLayoutRowMajor);
        matAcc = coopMatMulAdd(matA, matB, matAcc);
        barrier();
    }

    coopMatStore(matAcc, sharedC, 0, MMA_N, gl_CooperativeMatrixLayoutRowMajor);
    barrier();

    int baseRowC = mmaTileM * MMA_M;
    int baseColC = mmaTileN * MMA_N;

    int storeRowC = baseRowC + localID.y;
    int storeColC = baseColC + localID.x;

    if (storeRowC < M && storeColC < N) {
        float result = sharedC[localID.y * MMA_N + localID.x];
        imageStore(dstMat, ivec2(storeColC, storeRowC), vec4(result, 0.0, 0.0, 0.0));
    }
}