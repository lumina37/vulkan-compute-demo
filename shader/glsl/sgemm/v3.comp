#version 460

#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_EXT_shader_16bit_storage: require
#extension GL_EXT_shader_explicit_arithmetic_types_float16: require
#extension GL_KHR_memory_scope_semantics: require
#extension GL_KHR_cooperative_matrix: require

layout (local_size_x = 32, local_size_y = 1) in;

layout (binding = 0, r32f) uniform readonly image2D srcMatA;
layout (binding = 1, r32f) uniform readonly image2D srcMatB;
layout (binding = 2, r32f) uniform writeonly image2D dstMat;

layout (constant_id = 0) const int K = 0;
const int MMA_M = 16;
const int MMA_N = 16;
const int MMA_K = 16;

shared float16_t sharedA[MMA_M * MMA_K];
shared float16_t sharedB[MMA_K * MMA_N];
shared float sharedC[MMA_M * MMA_N];

void main() {
    const ivec2 groupSize = ivec2(gl_WorkGroupSize.xy);
    const ivec2 localID = ivec2(gl_LocalInvocationID.xy);
    const ivec2 groupID = ivec2(gl_WorkGroupID.xy);

    const ivec2 sizeA = imageSize(srcMatA);
    const ivec2 sizeB = imageSize(srcMatB);
    const int M = sizeA.y;
    const int N = sizeB.x;

    coopmat<float16_t, gl_ScopeSubgroup, MMA_M, MMA_K, gl_MatrixUseA> matA;
    coopmat<float16_t, gl_ScopeSubgroup, MMA_K, MMA_N, gl_MatrixUseB> matB;
    coopmat<float, gl_ScopeSubgroup, MMA_M, MMA_N, gl_MatrixUseAccumulator> matAcc;
    matAcc = coopmat<float, gl_ScopeSubgroup, MMA_M, MMA_N, gl_MatrixUseAccumulator>(0.0);

    const int blockTileCount = K / MMA_K;
    const int baseM = groupID.y * MMA_M;
    const int baseN = groupID.x * MMA_N;
    for (int iBlkTile = 0; iBlkTile < blockTileCount; iBlkTile++) {
        const int baseK = iBlkTile * MMA_K;
        const int elemsPerThreadA = MMA_M * MMA_K / groupSize.x;
        for (int i = 0; i < elemsPerThreadA; i++) {
            const int linearIdx = localID.x * elemsPerThreadA + i;
            const int srcX = baseK + linearIdx % MMA_K;
            const int srcY = baseM + linearIdx / MMA_K;
            const vec4 srcVal = imageLoad(srcMatA, ivec2(srcX, srcY));
            sharedA[linearIdx] = float16_t(srcVal.x);
        }

        const int elemsPerThreadB = MMA_K * MMA_N / groupSize.x;
        for (int i = 0; i < elemsPerThreadB; i++) {
            const int linearIdx = localID.x * elemsPerThreadB + i;
            const int srcX = baseN + linearIdx % MMA_N;
            const int srcY = baseK + linearIdx / MMA_N;
            const vec4 srcVal = imageLoad(srcMatB, ivec2(srcX, srcY));
            sharedB[linearIdx] = float16_t(srcVal.x);
        }
        barrier();

        coopMatLoad(matA, sharedA, 0, MMA_K, gl_CooperativeMatrixLayoutRowMajor);
        coopMatLoad(matB, sharedB, 0, MMA_N, gl_CooperativeMatrixLayoutRowMajor);
        matAcc = coopMatMulAdd(matA, matB, matAcc);
        barrier();
    }

    coopMatStore(matAcc, sharedC, 0, MMA_N, gl_CooperativeMatrixLayoutRowMajor);
    barrier();

    int elemsPerThread = MMA_M * MMA_N / groupSize.x;
    for (int i = 0; i < elemsPerThread; i++) {
        const int linearIdx = localID.x * elemsPerThread + i;
        const int dstX = baseN + linearIdx % MMA_K;
        const int dstY = baseM + linearIdx / MMA_K;
        float dstVal = sharedC[linearIdx];
        imageStore(dstMat, ivec2(dstX, dstY), vec4(dstVal, 0.0, 0.0, 0.0));
    }
}
