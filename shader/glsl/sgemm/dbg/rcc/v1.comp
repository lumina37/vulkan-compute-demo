// A/B/C in Row/Col/Col-major (RCC)
// sharedA is transposed

#version 460

#extension GL_EXT_control_flow_attributes : enable

layout (local_size_x_id = 0, local_size_y_id = 1) in;

layout (binding = 0, std430) readonly buffer SrcMatA { vec4 srcMatA[]; };
layout (binding = 1, std430) readonly buffer SrcMatB { vec4 srcMatB[]; };
layout (binding = 2, std430) writeonly buffer DstMat { vec4 dstMat[]; };

layout (constant_id = 2) const uint M = 0;
layout (constant_id = 3) const uint N = 0;
layout (constant_id = 4) const uint K = 0;
layout (constant_id = 5) const uint BLOCK_TILE_M = 128;
layout (constant_id = 6) const uint BLOCK_TILE_N = 128;
layout (constant_id = 7) const uint BLOCK_TILE_K = 32;
layout (constant_id = 8) const uint THREAD_TILE_M = 16;
layout (constant_id = 9) const uint THREAD_TILE_N = 16;
layout (constant_id = 10) const uint THREAD_TILE_K = 16;
layout (constant_id = 11) const uint THREAD_SUBTILE_M = 8;
layout (constant_id = 12) const uint THREAD_SUBTILE_N = 8;
layout (constant_id = 13) const uint THREAD_SUBTILE_K = 8;
const uint BLOCK_TILE_VEC_M = BLOCK_TILE_M / 4;
const uint BLOCK_TILE_VEC_K = BLOCK_TILE_K / 4;
const uint THREAD_TILE_VEC_M = THREAD_TILE_M / 4;
const uint THREAD_SUBTILE_VEC_M = THREAD_SUBTILE_M / 4;
const uint THREAD_SUBTILE_VEC_K = THREAD_SUBTILE_K / 4;
const uint STAGES = 2;

const uvec2 SHARED_EXTENT_A = uvec2(BLOCK_TILE_VEC_K, BLOCK_TILE_M);
const uvec2 SHARED_EXTENT_B = uvec2(BLOCK_TILE_VEC_K, BLOCK_TILE_N);
shared vec4 sharedA[STAGES][BLOCK_TILE_K][BLOCK_TILE_VEC_M];
shared vec4 sharedB[STAGES][BLOCK_TILE_N][BLOCK_TILE_VEC_K];

void zeroFillAccumulator(inout vec4 regAccumulator[THREAD_TILE_N][THREAD_TILE_VEC_M]) {
    [[unroll]] for (uint iterTN = 0; iterTN < THREAD_TILE_N; iterTN++) {
        [[unroll]] for (uint iterVecTM = 0; iterVecTM < THREAD_TILE_VEC_M; iterVecTM++) {
            regAccumulator[iterTN][iterVecTM] = vec4(0);
        }
    }
}

void loadGlobalToShared(uvec2 globalCoord, uvec2 globalExtent, uint globalRowStride, bool loadA, uint stage) {
    const uvec2 groupSize = gl_WorkGroupSize.xy;
    const uint localIndex = gl_LocalInvocationIndex;

    const uint groupThreadCount = groupSize.x * groupSize.y;
    const uint loadsPerThread = globalExtent.x * globalExtent.y / groupThreadCount;

    for (uint i = 0; i < loadsPerThread; i++) {
        const uint linearIdx = i * groupThreadCount + localIndex;
        const uvec2 srcOffset = uvec2(linearIdx % globalExtent.x, linearIdx / globalExtent.x);
        const uvec2 srcCoord = globalCoord + srcOffset;
        const uint srcIndex = srcCoord.y * globalRowStride + srcCoord.x;

        if (loadA) {
            const uvec2 dstCoord = uvec2(srcOffset.y, srcOffset.x * 4);
            const vec4 srcVal = srcMatA[srcIndex];
            sharedA[stage][dstCoord.y + 0][dstCoord.x / 4][dstCoord.x % 4] = srcVal.x;
            sharedA[stage][dstCoord.y + 1][dstCoord.x / 4][dstCoord.x % 4] = srcVal.y;
            sharedA[stage][dstCoord.y + 2][dstCoord.x / 4][dstCoord.x % 4] = srcVal.z;
            sharedA[stage][dstCoord.y + 3][dstCoord.x / 4][dstCoord.x % 4] = srcVal.w;
        } else {
            const uvec2 dstCoord = srcOffset;
            sharedB[stage][dstCoord.y][dstCoord.x] = srcMatB[srcIndex];
        }
    }
}

void computeSubThreadTile(inout vec4 regAccumulator[THREAD_TILE_N][THREAD_TILE_VEC_M], uint iterVecTM, uint iterTN, uint stage) {
    const uvec2 groupSize = gl_WorkGroupSize.xy;
    const uvec2 localID = gl_LocalInvocationID.xy;

    vec4 regA[THREAD_SUBTILE_K][THREAD_SUBTILE_VEC_M];
    vec4 regB[THREAD_SUBTILE_VEC_K];

    [[unroll]] for (uint iterBK = 0; iterBK < BLOCK_TILE_K; iterBK += THREAD_TILE_K) {
        [[unroll]] for (uint iterTK = 0; iterTK < THREAD_TILE_K; iterTK += THREAD_SUBTILE_K) {
            [[unroll]] for (uint iterSubTK = 0; iterSubTK < THREAD_SUBTILE_K; iterSubTK++) {
                const uint sharedCoordKA = iterBK + iterTK + iterSubTK;
                [[unroll]] for (uint iterVecSubTM = 0; iterVecSubTM < THREAD_SUBTILE_VEC_M; iterVecSubTM++) {
                    const uint sharedCoordVecMA = (iterVecTM + iterVecSubTM) * groupSize.x + localID.x;
                    regA[iterSubTK][iterVecSubTM] = sharedA[stage][sharedCoordKA][sharedCoordVecMA];
                }
            }

            [[unroll]] for (uint iterSubTN = 0; iterSubTN < THREAD_SUBTILE_N; iterSubTN++) {
                const uint regCoordN = iterTN + iterSubTN;
                const uint sharedCoordNB = (iterTN + iterSubTN) * groupSize.y + localID.y;

                [[unroll]] for (uint iterVecSubTK = 0; iterVecSubTK < THREAD_SUBTILE_VEC_K; iterVecSubTK++) {
                    const uint sharedCoordVecKB = (iterBK + iterTK) / 4 + iterVecSubTK;
                    regB[iterVecSubTK] = sharedB[stage][sharedCoordNB][sharedCoordVecKB];
                }

                [[unroll]] for (uint iterVecSubTM = 0; iterVecSubTM < THREAD_SUBTILE_VEC_M; iterVecSubTM++) {
                    const uint regCoordVecM = iterVecTM + iterVecSubTM;
                    [[unroll]] for (uint iterVecSubTK = 0; iterVecSubTK < THREAD_SUBTILE_VEC_K; iterVecSubTK++) {
                        const uint regBaseKB = iterVecSubTK * 4;
                        regAccumulator[regCoordN][regCoordVecM] += regB[iterVecSubTK].x * regA[regBaseKB + 0][iterVecSubTM];
                        regAccumulator[regCoordN][regCoordVecM] += regB[iterVecSubTK].y * regA[regBaseKB + 1][iterVecSubTM];
                        regAccumulator[regCoordN][regCoordVecM] += regB[iterVecSubTK].z * regA[regBaseKB + 2][iterVecSubTM];
                        regAccumulator[regCoordN][regCoordVecM] += regB[iterVecSubTK].w * regA[regBaseKB + 3][iterVecSubTM];
                    }
                }
            }
        }
    }
}

void computeWithShared(inout vec4 regAccumulator[THREAD_TILE_N][THREAD_TILE_VEC_M], uint stage) {
    [[unroll]] for (uint iterTN = 0; iterTN < THREAD_TILE_N; iterTN += THREAD_SUBTILE_N) {
        [[unroll]] for (uint iterVecTM = 0; iterVecTM < THREAD_TILE_VEC_M; iterVecTM += THREAD_SUBTILE_VEC_M) {
            computeSubThreadTile(regAccumulator, iterVecTM, iterTN, stage);
        }
    }
}

void storeAccumulator(vec4 regAccumulator[THREAD_TILE_N][THREAD_TILE_VEC_M]) {
    const uvec2 groupID = gl_WorkGroupID.xy;
    const uvec2 groupSize = gl_WorkGroupSize.xy;
    const uvec2 localID = gl_LocalInvocationID.xy;

    const uint globalBaseN = groupID.y * BLOCK_TILE_N + localID.y;
    const uint globalBaseVecM = groupID.x * BLOCK_TILE_VEC_M + localID.x;
    [[unroll]] for (uint iterTN = 0; iterTN < THREAD_TILE_N; iterTN++) {
        const uint globalCoordN = globalBaseN + iterTN * groupSize.y;
        [[unroll]] for (uint iterVecTM = 0; iterVecTM < THREAD_TILE_VEC_M; iterVecTM++) {
            const uint globalCoordVecM = globalBaseVecM + iterVecTM * groupSize.x;
            const uint dstIdx = globalCoordN * M / 4 + globalCoordVecM;
            dstMat[dstIdx] = regAccumulator[iterTN][iterVecTM];
        }
    }
}

void main() {
    const uvec2 groupID = gl_WorkGroupID.xy;

    // Accumulator
    vec4 regAccumulator[THREAD_TILE_N][THREAD_TILE_VEC_M];
    zeroFillAccumulator(regAccumulator);

    // Prologue
    uint stage = 0;
    const uvec2 globalCoordA = uvec2(0, groupID.x * BLOCK_TILE_M);
    loadGlobalToShared(globalCoordA, SHARED_EXTENT_A, K / 4, true, 0);// Load A

    const uvec2 globalCoordB = uvec2(0, groupID.y * BLOCK_TILE_N);
    loadGlobalToShared(globalCoordB, SHARED_EXTENT_B, K / 4, false, 0);// Load B
    barrier();

    // Main-loop
    const uint blockBaseM = groupID.x * BLOCK_TILE_M;
    const uint blockBaseN = groupID.y * BLOCK_TILE_N;
    [[unroll]] for (uint iterK = BLOCK_TILE_K; iterK < K; iterK += BLOCK_TILE_K) {
        const uint nextStage = (stage + 1) % STAGES;

        const uvec2 globalCoordA = uvec2(iterK / 4, blockBaseM);
        loadGlobalToShared(globalCoordA, SHARED_EXTENT_A, K / 4, true, nextStage);// Load A

        const uvec2 globalCoordB = uvec2(iterK / 4, blockBaseN);
        loadGlobalToShared(globalCoordB, SHARED_EXTENT_B, K / 4, false, nextStage);// Load B

        computeWithShared(regAccumulator, stage);

        stage = nextStage;
        barrier();
    }

    // Epilogue
    computeWithShared(regAccumulator, stage);

    // Store results
    storeAccumulator(regAccumulator);
}
