#version 460

layout (local_size_x_id = 0, local_size_y_id = 1) in;

layout (binding = 0, std430) readonly buffer SrcMatA { float srcMatA[]; };
layout (binding = 1, std430) readonly buffer SrcMatB { float srcMatB[]; };
layout (binding = 2, std430) writeonly buffer DstMat { float dstMat[]; };

layout (constant_id = 2) const int M = 0;
layout (constant_id = 3) const int N = 0;
layout (constant_id = 4) const int K = 0;
layout (constant_id = 5) const int THREAD_TILE_M = 4;
layout (constant_id = 6) const int THREAD_TILE_N = 4;
layout (constant_id = 7) const int THREAD_TILE_K = 4;

shared float sharedA[gl_WorkGroupSize.y * THREAD_TILE_M][THREAD_TILE_K];
shared float sharedB[gl_WorkGroupSize.x * THREAD_TILE_N][THREAD_TILE_K];

void main() {
    const ivec2 globalID = ivec2(gl_GlobalInvocationID.xy);
    const ivec2 groupSize = ivec2(gl_WorkGroupSize.xy);
    const ivec2 localID = ivec2(gl_LocalInvocationID.xy);
    const int localIndex = int(gl_LocalInvocationIndex);
    const ivec2 groupID = ivec2(gl_WorkGroupID.xy);
    const int groupThreadCount = groupSize.x * groupSize.y;

    // Accumulation registers for thread tile
    float acc[THREAD_TILE_M][THREAD_TILE_N];
    for (int tm = 0; tm < THREAD_TILE_M; tm++) {
        for (int tn = 0; tn < THREAD_TILE_N; tn++) {
            acc[tm][tn] = 0.0;
        }
    }

    const int blockTileCount = K / THREAD_TILE_K;
    for (int iBlkTile = 0; iBlkTile < blockTileCount; iBlkTile++) {
        // Load from srcMatA
        const int loadsPerThreadA = (THREAD_TILE_M * groupSize.y) * THREAD_TILE_K / groupThreadCount;
        for (int i = 0; i < loadsPerThreadA; i++) {
            const int linearIdx = i * groupThreadCount + localIndex;
            const int tk = linearIdx % THREAD_TILE_K;
            const int tm = linearIdx / THREAD_TILE_K;
            const int srcCol = iBlkTile * THREAD_TILE_K + tk;
            const int srcRow = (groupID.y * groupSize.y) * THREAD_TILE_M + tm;
            const int srcAIndex = srcRow * K + srcCol;
            sharedA[tm][tk] = srcMatA[srcAIndex];
        }

        // Load from srcMatB
        const int loadsPerThreadB = (THREAD_TILE_N * groupSize.x) * THREAD_TILE_K / groupThreadCount;
        for (int i = 0; i < loadsPerThreadB; i++) {
            const int linearIdx = i * groupThreadCount + localIndex;
            const int tn = linearIdx % (THREAD_TILE_N * groupSize.x);
            const int tk = linearIdx / (THREAD_TILE_N * groupSize.x);
            const int srcCol = (groupID.x * groupSize.x) * THREAD_TILE_N + tn;
            const int srcRow = iBlkTile * THREAD_TILE_K + tk;
            const int srcBIndex = srcRow * N + srcCol;
            sharedB[tn][tk] = srcMatB[srcBIndex];// transpose
        }
        barrier();

        // Compute
        for (int tm = 0; tm < THREAD_TILE_M; tm++) {
            const int yA = localID.y * THREAD_TILE_M + tm;
            for (int tn = 0; tn < THREAD_TILE_N; tn++) {
                const int yB = localID.x * THREAD_TILE_N + tn;
                for (int tk = 0; tk < THREAD_TILE_K; tk++) {
                    const float valA = sharedA[yA][tk];
                    const float valB = sharedB[yB][tk];
                    acc[tm][tn] += valA * valB;
                }
            }
        }
        barrier();
    }

    // Store results
    for (int tm = 0; tm < THREAD_TILE_M; tm++) {
        for (int tn = 0; tn < THREAD_TILE_N; tn++) {
            const int globalRow = globalID.y * THREAD_TILE_M + tm;
            const int globalCol = globalID.x * THREAD_TILE_N + tn;
            const int dstIdx = globalRow * N + globalCol;
            dstMat[dstIdx] = acc[tm][tn];
        }
    }
}
